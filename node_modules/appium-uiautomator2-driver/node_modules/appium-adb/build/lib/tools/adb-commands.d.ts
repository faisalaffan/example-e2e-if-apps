export default methods;
export type ResolveActivityOptions = {
    /**
     * Whether to prefer `cmd` tool usage for
     * launchable activity name detection. It might be useful to disable it if
     * `cmd package resolve-activity` returns 'android/com.android.internal.app.ResolverActivity',
     * which means the app has no default handler set in system settings.
     * See https://github.com/appium/appium/issues/17128 for more details.
     * This option has no effect if the target Android version is below 24 as there
     * the corresponding `cmd` subcommand is not implemented and dumpsys usage is the only
     * possible way to detect the launchable activity name.
     */
    preferCmd?: boolean | null | undefined;
};
export type LogcatOpts = {
    /**
     * The log print format, where <format> is one of:
     * brief process tag thread raw time threadtime long
     * `threadtime` is the default value.
     */
    format?: string | undefined;
    /**
     * Series of `<tag>[:priority]`
     * where `<tag>` is a log component tag (or `*` for all) and priority is:
     * V    Verbose
     * D    Debug
     * I    Info
     * W    Warn
     * E    Error
     * F    Fatal
     * S    Silent (supress all output)
     *
     * `'*'` means `'*:d'` and `<tag>` by itself means `<tag>:v`
     *
     * If not specified on the commandline, filterspec is set from `ANDROID_LOG_TAGS`.
     * If no filterspec is found, filter defaults to `'*:I'`
     */
    filterSpecs?: string[] | undefined;
};
/**
 * Listener function, which accepts one argument.
 *
 * The argument is a log record object with `timestamp`, `level` and `message` properties.
 */
export type LogcatListener = (record: LogcatRecord) => any;
export type LogcatRecord = {
    timestamp: number;
    level: string;
    message: string;
};
export type setPropOpts = {
    /**
     * - Do we run setProp as a privileged command? Default true.
     */
    privileged: boolean;
};
export type ScreenrecordOptions = {
    /**
     * - The format is widthxheight.
     * The default value is the device's native display resolution (if supported),
     * 1280x720 if not. For best results,
     * use a size supported by your device's Advanced Video Coding (AVC) encoder.
     * For example, "1280x720"
     */
    videoSize: string | null;
    /**
     * - Set it to `true` in order to display additional information on the video overlay,
     *   such as a timestamp, that is helpful in videos captured to illustrate bugs.
     *   This option is only supported since API level 27 (Android P).
     */
    bugReport: boolean | null;
    /**
     * - The maximum recording time, in seconds.
     *   The default (and maximum) value is 180 (3 minutes).
     */
    timeLimit: (string | number) | null;
    /**
     * - The video bit rate for the video, in megabits per second.
     * The default value is 4. You can increase the bit rate to improve video quality,
     * but doing so results in larger movie files.
     */
    bitRate: (string | number) | null;
};
export type ADBCommands = typeof methods;
declare namespace methods {
    /**
     * Creates chunks for the given arguments and executes them in `adb shell`.
     * This is faster than calling `adb shell` separately for each arg, however
     * there is a limit for a maximum length of a single adb command. that is why
     * we need all this complicated logic.
     *
     * @param {Function} argTransformer A function, that receives single argument
     * from the `args` array and transforms it into a shell command. The result
     * of the function must be an array, where each item is a part of a single command.
     * The last item of the array could be ';'. If this is not a semicolon then it is going to
     * be added automatically.
     * @param {Array<number|string>} args Array of argument values to create chunks for
     * @throws {Error} If any of the chunks returns non-zero exit code after being executed
     */
    function shellChunks(argTransformer: Function, args: (string | number)[]): Promise<void>;
    /**
     * Get the path to adb executable amd assign it
     * to this.executable.path and this.binaries.adb properties.
     *
     * @return {Promise<ADB>} ADB instance.
     */
    function getAdbWithCorrectAdbPath(): Promise<ADB>;
    /**
     * Get the full path to aapt tool and assign it to
     * this.binaries.aapt property
     */
    function initAapt(): Promise<void>;
    /**
     * Get the full path to aapt2 tool and assign it to
     * this.binaries.aapt2 property
     */
    function initAapt2(): Promise<void>;
    /**
     * Get the full path to zipalign tool and assign it to
     * this.binaries.zipalign property
     */
    function initZipAlign(): Promise<void>;
    /**
     * Get the full path to bundletool binary and assign it to
     * this.binaries.bundletool property
     */
    function initBundletool(): Promise<void>;
    /**
     * Retrieve the API level of the device under test.
     *
     * @return {Promise<number>} The API level as integer number, for example 21 for
     *                  Android Lollipop. The result of this method is cached, so all the further
     * calls return the same value as the first one.
     */
    function getApiLevel(): Promise<number>;
    /**
     * Retrieve the platform version of the device under test.
     *
     * @return {Promise<string>} The platform version as a string, for example '5.0' for
     * Android Lollipop.
     */
    function getPlatformVersion(): Promise<string>;
    /**
     * Verify whether a device is connected.
     *
     * @return {Promise<boolean>} True if at least one device is visible to adb.
     */
    function isDeviceConnected(): Promise<boolean>;
    /**
     * Recursively create a new folder on the device under test.
     *
     * @param {string} remotePath - The new path to be created.
     * @return {Promise<string>} mkdir command output.
     */
    function mkdir(remotePath: string): Promise<string>;
    /**
     * Verify whether the given argument is a
     * valid class name.
     *
     * @param {string} classString - The actual class name to be verified.
     * @return {RegExpExecArray|null} The result of Regexp.exec operation
     *                          or _null_ if no matches are found.
     */
    function isValidClass(classString: string): RegExpExecArray | null;
    /**
     * @typedef {Object} ResolveActivityOptions
     * @property {boolean?} [preferCmd=true] Whether to prefer `cmd` tool usage for
     * launchable activity name detection. It might be useful to disable it if
     * `cmd package resolve-activity` returns 'android/com.android.internal.app.ResolverActivity',
     * which means the app has no default handler set in system settings.
     * See https://github.com/appium/appium/issues/17128 for more details.
     * This option has no effect if the target Android version is below 24 as there
     * the corresponding `cmd` subcommand is not implemented and dumpsys usage is the only
     * possible way to detect the launchable activity name.
     */
    /**
     * Fetches the fully qualified name of the launchable activity for the
     * given package. It is expected the package is already installed on
     * the device under test.
     *
     * @param {string} pkg - The target package identifier
     * @param {ResolveActivityOptions?} opts
     * @return {Promise<string>} Fully qualified name of the launchable activity
     * @throws {Error} If there was an error while resolving the activity name
     */
    function resolveLaunchableActivity(pkg: string, opts?: ResolveActivityOptions | null): Promise<string>;
    /**
     * Force application to stop on the device under test.
     *
     * @param {string} pkg - The package name to be stopped.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function forceStop(pkg: string): Promise<string>;
    /**
     * Kill application
     *
     * @param {string} pkg - The package name to be stopped.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function killPackage(pkg: string): Promise<string>;
    /**
     * Clear the user data of the particular application on the device
     * under test.
     *
     * @param {string} pkg - The package name to be cleared.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function clear(pkg: string): Promise<string>;
    /**
     * Grant all permissions requested by the particular package.
     * This method is only useful on Android 6.0+ and for applications
     * that support components-based permissions setting.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} [apk] - The path to the actual apk file.
     * @throws {Error} If there was an error while granting permissions
     */
    function grantAllPermissions(pkg: string, apk?: string | undefined): Promise<void>;
    /**
     * Grant multiple permissions for the particular package.
     * This call is more performant than `grantPermission` one, since it combines
     * multiple `adb shell` calls into a single command.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {Array<string>} permissions - The list of permissions to be granted.
     * @throws {Error} If there was an error while changing permissions.
     */
    function grantPermissions(pkg: string, permissions: string[]): Promise<void>;
    /**
     * Grant single permission for the particular package.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} permission - The full name of the permission to be granted.
     * @throws {Error} If there was an error while changing permissions.
     */
    function grantPermission(pkg: string, permission: string): Promise<void>;
    /**
     * Revoke single permission from the particular package.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} permission - The full name of the permission to be revoked.
     * @throws {Error} If there was an error while changing permissions.
     */
    function revokePermission(pkg: string, permission: string): Promise<void>;
    /**
     * Retrieve the list of granted permissions for the particular package.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} [cmdOutput=null] - Optional parameter containing command output of
     *                                    _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of granted permissions or an empty list.
     * @throws {Error} If there was an error while changing permissions.
     */
    function getGrantedPermissions(pkg: string, cmdOutput?: string | undefined): Promise<string[]>;
    /**
     * Retrieve the list of denied permissions for the particular package.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} [cmdOutput=null] - Optional parameter containing command output of
     *                                    _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of denied permissions or an empty list.
     */
    function getDeniedPermissions(pkg: string, cmdOutput?: string | undefined): Promise<string[]>;
    /**
     * Retrieve the list of requested permissions for the particular package.
     *
     * @param {string} pkg - The package name to be processed.
     * @param {string} [cmdOutput=null] - Optional parameter containing command output of
     *                                    _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of requested permissions or an empty list.
     */
    function getReqPermissions(pkg: string, cmdOutput?: string | undefined): Promise<string[]>;
    /**
     * Retrieve the list of location providers for the device under test.
     *
     * @return {Promise<string[]>} The list of available location providers or an empty list.
     */
    function getLocationProviders(): Promise<string[]>;
    /**
     * Toggle the state of GPS location provider.
     *
     * @param {boolean} enabled - Whether to enable (true) or disable (false) the GPS provider.
     */
    function toggleGPSLocationProvider(enabled: boolean): Promise<void>;
    /**
     * Set hidden api policy to manage access to non-SDK APIs.
     * https://developer.android.com/preview/restrictions-non-sdk-interfaces
     *
     * @param {number|string} value - The API enforcement policy.
     *     For Android P
     *     0: Disable non-SDK API usage detection. This will also disable logging, and also break the strict mode API,
     *        detectNonSdkApiUsage(). Not recommended.
     *     1: "Just warn" - permit access to all non-SDK APIs, but keep warnings in the log.
     *        The strict mode API will keep working.
     *     2: Disallow usage of dark grey and black listed APIs.
     *     3: Disallow usage of blacklisted APIs, but allow usage of dark grey listed APIs.
     *
     *     For Android Q
     *     https://developer.android.com/preview/non-sdk-q#enable-non-sdk-access
     *     0: Disable all detection of non-SDK interfaces. Using this setting disables all log messages for non-SDK interface usage
     *        and prevents you from testing your app using the StrictMode API. This setting is not recommended.
     *     1: Enable access to all non-SDK interfaces, but print log messages with warnings for any non-SDK interface usage.
     *        Using this setting also allows you to test your app using the StrictMode API.
     *     2: Disallow usage of non-SDK interfaces that belong to either the black list
     *        or to a restricted greylist for your target API level.
     *
     * @param {boolean} [ignoreError=false] Whether to ignore an exception in 'adb shell settings put global' command
     * @throws {error} If there was an error and ignoreError was true while executing 'adb shell settings put global'
     *                 command on the device under test.
     */
    function setHiddenApiPolicy(value: string | number, ignoreError?: boolean | undefined): Promise<void>;
    /**
     * Reset access to non-SDK APIs to its default setting.
     * https://developer.android.com/preview/restrictions-non-sdk-interfaces
     *
     * @param {boolean} [ignoreError=false] Whether to ignore an exception in 'adb shell settings delete global' command
     * @throws {error} If there was an error and ignoreError was true while executing 'adb shell settings delete global'
     *                 command on the device under test.
     */
    function setDefaultHiddenApiPolicy(ignoreError?: boolean | undefined): Promise<void>;
    /**
     * Stop the particular package if it is running and clears its application data.
     *
     * @param {string} pkg - The package name to be processed.
     */
    function stopAndClear(pkg: string): Promise<void>;
    /**
     * Retrieve the list of available input methods (IMEs) for the device under test.
     *
     * @return {Promise<string[]>} The list of IME names or an empty list.
     */
    function availableIMEs(): Promise<string[]>;
    /**
     * Retrieve the list of enabled input methods (IMEs) for the device under test.
     *
     * @return {Promise<string[]>} The list of enabled IME names or an empty list.
     */
    function enabledIMEs(): Promise<string[]>;
    /**
     * Enable the particular input method on the device under test.
     *
     * @param {string} imeId - One of existing IME ids.
     */
    function enableIME(imeId: string): Promise<void>;
    /**
     * Disable the particular input method on the device under test.
     *
     * @param {string} imeId - One of existing IME ids.
     */
    function disableIME(imeId: string): Promise<void>;
    /**
     * Set the particular input method on the device under test.
     *
     * @param {string} imeId - One of existing IME ids.
     */
    function setIME(imeId: string): Promise<void>;
    /**
     * Get the default input method on the device under test.
     *
     * @return {Promise<string|null>} The name of the default input method
     */
    function defaultIME(): Promise<string | null>;
    /**
     * Send the particular keycode to the device under test.
     *
     * @param {string|number} keycode - The actual key code to be sent.
     */
    function keyevent(keycode: string | number): Promise<void>;
    /**
     * Send the particular text or a number to the device under test.
     * The text gets properly escaped before being passed to ADB.
     * Noop if the text is empty.
     *
     * @param {string|number} text - The actual text to be sent.
     * @throws {Error} If it is impossible to escape the given string
     */
    function inputText(text: string | number): Promise<void>;
    /**
     * Clear the active text field on the device under test by sending
     * special keyevents to it.
     *
     * @param {number} [length=100] - The maximum length of the text in the field to be cleared.
     */
    function clearTextField(length?: number | undefined): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to lock it.
     */
    function lock(): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to emulate
     * Back button tap.
     */
    function back(): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to emulate
     * Home button tap.
     */
    function goToHome(): Promise<void>;
    /**
     * @return {string} the actual path to adb executable.
     */
    function getAdbPath(): string;
    /**
     * Retrieve current screen orientation of the device under test.
     *
     * @return {Promise<number>} The current orientation encoded as an integer number.
     */
    function getScreenOrientation(): Promise<number>;
    /**
     * Send an arbitrary Telnet command to the device under test.
     *
     * @param {string} command - The command to be sent.
     *
     * @return {Promise<string>} The actual output of the given command.
     */
    function sendTelnetCommand(command: string): Promise<string>;
    /**
     * Check the state of Airplane mode on the device under test.
     *
     * @return {Promise<boolean>} True if Airplane mode is enabled.
     */
    function isAirplaneModeOn(): Promise<boolean>;
    /**
     * Change the state of Airplane mode in Settings on the device under test.
     *
     * @param {boolean} on - True to enable the Airplane mode in Settings and false to disable it.
     */
    function setAirplaneMode(on: boolean): Promise<void>;
    /**
     * Broadcast the state of Airplane mode on the device under test.
     * This method should be called after {@link #setAirplaneMode}, otherwise
     * the mode change is not going to be applied for the device.
     * ! This API requires root since Android API 24. Since API 30
     * there is a dedicated adb command to change airplane mode state, which
     * does not require to call this one afterwards.
     *
     * @param {boolean} on - True to broadcast enable and false to broadcast disable.
     */
    function broadcastAirplaneMode(on: boolean): Promise<void>;
    /**
     * Check the state of WiFi on the device under test.
     *
     * @return {Promise<boolean>} True if WiFi is enabled.
     */
    function isWifiOn(): Promise<boolean>;
    /**
     * Check the state of Data transfer on the device under test.
     *
     * @return {Promise<boolean>} True if Data transfer is enabled.
     */
    function isDataOn(): Promise<boolean>;
    /**
     * Change the state of WiFi and/or Data transfer on the device under test.
     *
     * @param {{wifi?: boolean, data?: boolean}} opts - True to enable wifi and data transfer
     * @param {boolean} [isEmulator] - Set it to true if the device under test is an emulator rather than a real device.
     */
    function setWifiAndData({ wifi, data }: {
        wifi?: boolean | undefined;
        data?: boolean | undefined;
    }, isEmulator?: boolean | undefined): Promise<void>;
    /**
     * Check the state of animation on the device under test.
     *
     * @return {Promise<boolean>} True if at least one of animation scale settings
     *                   is not equal to '0.0'.
     */
    function isAnimationOn(): Promise<boolean>;
    /**
     * Forcefully recursively remove a path on the device under test.
     * Be careful while calling this method.
     *
     * @param {string} path - The path to be removed recursively.
     */
    function rimraf(path: string): Promise<void>;
    /**
     * Send a file to the device under test.
     *
     * @param {string} localPath - The path to the file on the local file system.
     * @param {string} remotePath - The destination path on the remote device.
     * @param {object} [opts] - Additional options mapping. See
     *                        https://github.com/appium/node-teen_process,
     *                        _exec_ method options, for more information about available
     *                        options.
     */
    function push(localPath: string, remotePath: string, opts?: object | undefined): Promise<void>;
    /**
     * Receive a file from the device under test.
     *
     * @param {string} remotePath - The source path on the remote device.
     * @param {string} localPath - The destination path to the file on the local file system.
     * @param {object} opts - Additional options mapping. See
     *                        https://github.com/appium/node-teen_process,
     *                        _exec_ method options, for more information about available
     *                        options.
     */
    function pull(remotePath: string, localPath: string, opts?: object): Promise<void>;
    /**
     * Check whether the process with the particular name is running on the device
     * under test.
     *
     * @param {string} processName - The name of the process to be checked.
     * @return {Promise<boolean>} True if the given process is running.
     * @throws {Error} If the given process name is not a valid class name.
     */
    function processExists(processName: string): Promise<boolean>;
    /**
     * Get TCP port forwarding with adb on the device under test.
     * @return {Promise<string[]>} The output of the corresponding adb command. An array contains each forwarding line of output
     */
    function getForwardList(): Promise<string[]>;
    /**
     * Setup TCP port forwarding with adb on the device under test.
     *
     * @param {string|number} systemPort - The number of the local system port.
     * @param {string|number} devicePort - The number of the remote device port.
     */
    function forwardPort(systemPort: string | number, devicePort: string | number): Promise<void>;
    /**
     * Remove TCP port forwarding with adb on the device under test. The forwarding
     * for the given port should be setup with {@link #forwardPort} first.
     *
     * @param {string|number} systemPort - The number of the local system port
     *                                     to remove forwarding on.
     */
    function removePortForward(systemPort: string | number): Promise<void>;
    /**
     * Get TCP port forwarding with adb on the device under test.
     * @return {Promise<string[]>} The output of the corresponding adb command. An array contains each forwarding line of output
     */
    function getReverseList(): Promise<string[]>;
    /**
     * Setup TCP port forwarding with adb on the device under test.
     * Only available for API 21+.
     *
     * @param {string|number} devicePort - The number of the remote device port.
     * @param {string|number} systemPort - The number of the local system port.
     */
    function reversePort(devicePort: string | number, systemPort: string | number): Promise<void>;
    /**
     * Remove TCP port forwarding with adb on the device under test. The forwarding
     * for the given port should be setup with {@link #forwardPort} first.
     *
     * @param {string|number} devicePort - The number of the remote device port
     *                                     to remove forwarding on.
     */
    function removePortReverse(devicePort: string | number): Promise<void>;
    /**
     * Setup TCP port forwarding with adb on the device under test. The difference
     * between {@link #forwardPort} is that this method does setup for an abstract
     * local port.
     *
     * @param {string|number} systemPort - The number of the local system port.
     * @param {string|number} devicePort - The number of the remote device port.
     */
    function forwardAbstractPort(systemPort: string | number, devicePort: string | number): Promise<void>;
    /**
     * Execute ping shell command on the device under test.
     *
     * @return {Promise<boolean>} True if the command output contains 'ping' substring.
     * @throws {error} If there was an error while executing 'ping' command on the
     *                 device under test.
     */
    function ping(): Promise<boolean>;
    /**
     * Restart the device under test using adb commands.
     *
     * @throws {error} If start fails.
     */
    function restart(): Promise<void>;
    /**
     * @typedef {Object} LogcatOpts
     * @property {string} [format] The log print format, where <format> is one of:
     *   brief process tag thread raw time threadtime long
     * `threadtime` is the default value.
     * @property {Array<string>} [filterSpecs] Series of `<tag>[:priority]`
     * where `<tag>` is a log component tag (or `*` for all) and priority is:
     *  V    Verbose
     *  D    Debug
     *  I    Info
     *  W    Warn
     *  E    Error
     *  F    Fatal
     *  S    Silent (supress all output)
     *
     * `'*'` means `'*:d'` and `<tag>` by itself means `<tag>:v`
     *
     * If not specified on the commandline, filterspec is set from `ANDROID_LOG_TAGS`.
     * If no filterspec is found, filter defaults to `'*:I'`
     */
    /**
     * Start the logcat process to gather logs.
     *
     * @param {LogcatOpts} [opts]
     * @throws {Error} If restart fails.
     */
    function startLogcat(opts?: LogcatOpts | undefined): Promise<void>;
    /**
     * Stop the active logcat process which gathers logs.
     * The call will be ignored if no logcat process is running.
     */
    function stopLogcat(): Promise<void>;
    /**
     * Retrieve the output from the currently running logcat process.
     * The logcat process should be executed by {2link #startLogcat} method.
     *
     * @return {string} The collected logcat output.
     * @throws {Error} If logcat process is not running.
     */
    function getLogcatLogs(): string;
    /**
     * Listener function, which accepts one argument.
     *
     * The argument is a log record object with `timestamp`, `level` and `message` properties.
     * @callback LogcatListener
     * @param {LogcatRecord} record
     */
    /**
     * @typedef LogcatRecord
     * @property {number} timestamp
     * @property {string} level
     * @property {string} message
     */
    /**
     * Set the callback for the logcat output event.
     *
     * @param {LogcatListener} listener - Listener function
     * @throws {Error} If logcat process is not running.
     */
    function setLogcatListener(listener: LogcatListener): void;
    /**
     * Removes the previously set callback for the logcat output event.
     *
     * @param {LogcatListener} listener - The listener function, which has been previously
     *                              passed to `setLogcatListener`
     * @throws {Error} If logcat process is not running.
     */
    function removeLogcatListener(listener: LogcatListener): void;
    /**
     * At some point of time Google has changed the default `ps` behaviour, so it only
     * lists processes that belong to the current shell user rather to all
     * users. It is necessary to execute ps with -A command line argument
     * to mimic the previous behaviour.
     *
     * @returns {Promise<string>} the output of `ps` command where all processes are included
     */
    function listProcessStatus(): Promise<string>;
    /**
     * Returns process name for the given process identifier
     *
     * @param {string|number} pid - The valid process identifier
     * @throws {Error} If the given PID is either invalid or is not present
     * in the active processes list
     * @returns {Promise<string>} The process name
     */
    function getNameByPid(pid: string | number): Promise<string>;
    /**
     * Get the list of process ids for the particular process on the device under test.
     *
     * @param {string} name - The part of process name.
     * @return {Promise<number[]>} The list of matched process IDs or an empty list.
     * @throws {Error} If the passed process name is not a valid one
     */
    function getPIDsByName(name: string): Promise<number[]>;
    /**
     * Get the list of process ids for the particular process on the device under test.
     *
     * @param {string} name - The part of process name.
     * @return {Promise<number[]>} The list of matched process IDs or an empty list.
     */
    function killProcessesByName(name: string): Promise<number[]>;
    /**
     * Kill the particular process on the device under test.
     * The current user is automatically switched to root if necessary in order
     * to properly kill the process.
     *
     * @param {string|number} pid - The ID of the process to be killed.
     * @throws {Error} If the process cannot be killed.
     */
    function killProcessByPID(pid: string | number): Promise<void>;
    /**
     * Broadcast process killing on the device under test.
     *
     * @param {string} intent - The name of the intent to broadcast to.
     * @param {string} processName - The name of the killed process.
     * @throws {error} If the process was not killed.
     */
    function broadcastProcessEnd(intent: string, processName: string): Promise<void>;
    /**
     * Broadcast a message to the given intent.
     *
     * @param {string} intent - The name of the intent to broadcast to.
     * @throws {error} If intent name is not a valid class name.
     */
    function broadcast(intent: string): Promise<void>;
    /**
     * Kill Android instruments if they are currently running.
     */
    function endAndroidCoverage(): Promise<void>;
    /**
     * Instrument the particular activity.
     *
     * @param {string} pkg - The name of the package to be instrumented.
     * @param {string} activity - The name of the main activity in this package.
     * @param {string} instrumentWith - The name of the package to instrument
     *                                  the activity with.
     * @throws {error} If any exception is reported by adb shell.
     */
    function instrument(pkg: string, activity: string, instrumentWith: string): Promise<void>;
    /**
     * Collect Android coverage by instrumenting the particular activity.
     *
     * @param {string} instrumentClass - The name of the instrumentation class.
     * @param {string} waitPkg - The name of the package to be instrumented.
     * @param {string} waitActivity - The name of the main activity in this package.
     *
     * @return {Promise<void>} The promise is successfully resolved if the instrumentation starts
     *                   without errors.
     */
    function androidCoverage(instrumentClass: string, waitPkg: string, waitActivity: string): Promise<void>;
    /**
     * Get the particular property of the device under test.
     *
     * @param {string} property - The name of the property. This name should
     *                            be known to _adb shell getprop_ tool.
     *
     * @return {Promise<string>} The value of the given property.
     */
    function getDeviceProperty(property: string): Promise<string>;
    /**
     * @typedef {object} setPropOpts
     * @property {boolean} privileged - Do we run setProp as a privileged command? Default true.
     */
    /**
     * Set the particular property of the device under test.
     *
     * @param {string} property - The name of the property. This name should
     *                            be known to _adb shell setprop_ tool.
     * @param {string} val - The new property value.
     * @param {setPropOpts} opts
     *
     * @throws {error} If _setprop_ utility fails to change property value.
     */
    function setDeviceProperty(prop: any, val: string, opts?: setPropOpts): Promise<void>;
    /**
     * @return {Promise<string>} Current system language on the device under test.
     */
    function getDeviceSysLanguage(): Promise<string>;
    /**
     * @return {Promise<string>} Current country name on the device under test.
     */
    function getDeviceSysCountry(): Promise<string>;
    /**
     * @return {Promise<string>} Current system locale name on the device under test.
     */
    function getDeviceSysLocale(): Promise<string>;
    /**
     * @return {Promise<string>} Current product language name on the device under test.
     */
    function getDeviceProductLanguage(): Promise<string>;
    /**
     * @return {Promise<string>} Current product country name on the device under test.
     */
    function getDeviceProductCountry(): Promise<string>;
    /**
     * @return {Promise<string>} Current product locale name on the device under test.
     */
    function getDeviceProductLocale(): Promise<string>;
    /**
     * @return {Promise<string>} The model name of the device under test.
     */
    function getModel(): Promise<string>;
    /**
     * @return {Promise<string>} The manufacturer name of the device under test.
     */
    function getManufacturer(): Promise<string>;
    /**
     * Get the current screen size.
     *
     * @return {Promise<string>} Device screen size as string in format 'WxH' or
     *                  _null_ if it cannot be determined.
     */
    function getScreenSize(): Promise<string>;
    /**
     * Get the current screen density in dpi
     *
     * @return {Promise<number|null>} Device screen density as a number or _null_ if it
     *                  cannot be determined
     */
    function getScreenDensity(): Promise<number | null>;
    /**
     * Setup HTTP proxy in device global settings.
     * Read https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r21/core/java/android/provider/Settings.java for each property
     *
     * @param {string} proxyHost - The host name of the proxy.
     * @param {string|number} proxyPort - The port number to be set.
     */
    function setHttpProxy(proxyHost: string, proxyPort: string | number): Promise<void>;
    /**
     * Delete HTTP proxy in device global settings.
     * Rebooting the test device is necessary to apply the change.
     */
    function deleteHttpProxy(): Promise<void>;
    /**
     * Set device property.
     * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
     *
     * @param {string} namespace - one of {system, secure, global}, case-insensitive.
     * @param {string} setting - property name.
     * @param {string|number} value - property value.
     * @return {Promise<string>} command output.
     */
    function setSetting(namespace: string, setting: string, value: string | number): Promise<string>;
    /**
     * Get device property.
     * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
     *
     * @param {string} namespace - one of {system, secure, global}, case-insensitive.
     * @param {string} setting - property name.
     * @return {Promise<string>} property value.
     */
    function getSetting(namespace: string, setting: string): Promise<string>;
    /**
     * Retrieve the `adb bugreport` command output. This
     * operation may take up to several minutes.
     *
     * @param {?number} [timeout=120000] - Command timeout in milliseconds
     * @returns {Promise<string>} Command stdout
     */
    function bugreport(timeout?: number | null | undefined): Promise<string>;
    /**
     * @typedef {Object} ScreenrecordOptions
     * @property {?string} videoSize - The format is widthxheight.
     *                  The default value is the device's native display resolution (if supported),
     *                  1280x720 if not. For best results,
     *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
     *                  For example, "1280x720"
     * @property {?boolean} bugReport - Set it to `true` in order to display additional information on the video overlay,
     *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
     *                                  This option is only supported since API level 27 (Android P).
     * @property {?string|number} timeLimit - The maximum recording time, in seconds.
     *                                        The default (and maximum) value is 180 (3 minutes).
     * @property {?string|number} bitRate - The video bit rate for the video, in megabits per second.
     *                The default value is 4. You can increase the bit rate to improve video quality,
     *                but doing so results in larger movie files.
     */
    /**
     * Initiate screenrecord utility on the device
     *
     * @param {string} destination - Full path to the writable media file destination
     *                               on the device file system.
     * @param {?ScreenrecordOptions} [options={}]
     * @returns {SubProcess} screenrecord process, which can be then controlled by the client code
     */
    function screenrecord(destination: string, options?: ScreenrecordOptions | null | undefined): SubProcess;
    /**
     * Executes the given function with the given input method context
     * and then restores the IME to the original value
     *
     * @param {string} ime - Valid IME identifier
     * @param {Function} fn - Function to execute
     * @returns {Promise<any>} The result of the given function
     */
    function runInImeContext(ime: string, fn: Function): Promise<any>;
    /**
     * Get tz database time zone formatted timezone
     *
     * @returns {Promise<string>} TZ database Time Zones format
     *
     * @throws {error} If any exception is reported by adb shell.
     */
    function getTimeZone(): Promise<string>;
    /**
     * Retrieves the list of features supported by the device under test
     *
     * @returns {Promise<string[]>} the list of supported feature names or an empty list.
     * An example adb command output:
     * ```
     * cmd
     * ls_v2
     * fixed_push_mkdir
     * shell_v2
     * abb
     * stat_v2
     * apex
     * abb_exec
     * remount_shell
     * fixed_push_symlink_timestamp
     * ```
     * @throws {Error} if there was an error while retrieving the list
     */
    function listFeatures(): Promise<string[]>;
    /**
     * Checks the state of streamed install feature.
     * This feature allows to speed up apk installation
     * since it does not require the original apk to be pushed to
     * the device under test first, which also saves space.
     * Although, it is required that both the device under test
     * and the adb server have the mentioned functionality.
     * See https://github.com/aosp-mirror/platform_system_core/blob/master/adb/client/adb_install.cpp
     * for more details
     *
     * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
     * device under test
     */
    function isStreamedInstallSupported(): Promise<boolean>;
    /**
     * Checks whether incremental install feature is supported by ADB.
     * Read https://developer.android.com/preview/features#incremental
     * for more details on it.
     *
     * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
     * device under test
     */
    function isIncrementalInstallSupported(): Promise<boolean>;
    /**
     * Retrieves the list of packages from Doze whitelist on Android 8+
     *
     * @returns {Promise<string[]>} The list of whitelisted packages. An example output:
     * system,com.android.shell,2000
     * system,com.google.android.cellbroadcastreceiver,10143
     * user,io.appium.settings,10157
     */
    function getDeviceIdleWhitelist(): Promise<string[]>;
    /**
     * Adds an existing package(s) into the Doze whitelist on Android 8+
     *
     * @param  {...string} packages One or more packages to add. If the package
     * already exists in the whitelist then it is only going to be added once.
     * If the package with the given name is not installed/not known then an error
     * will be thrown.
     * @returns {Promise<Boolean>} `true` if the command to add package(s) has been executed
     */
    function addToDeviceIdleWhitelist(...packages: string[]): Promise<boolean>;
    /**
     * Takes a screenshot of the given display or the default display.
     *
     * @this {ADB}
     * @param {number|string?} displayId A valid display identifier. If
     * no identifier is provided then the screenshot of the default display is returned.
     * Note that only recent Android APIs provide multi-screen support.
     * @returns {Promise<Buffer>} PNG screenshot payload
     */
    function takeScreenshot(this: ADB, displayId: string | number | null): Promise<Buffer>;
}
import { SubProcess } from 'teen_process';
//# sourceMappingURL=adb-commands.d.ts.map