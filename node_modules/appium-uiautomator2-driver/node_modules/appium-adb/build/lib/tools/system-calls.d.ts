export default systemCallMethods;
export type ConnectedDevicesOptions = {
    /**
     * - Whether to get long output, which includes extra properties in each device.
     * Akin to running `adb devices -l`.
     */
    verbose: boolean | null;
};
export type Device = {
    /**
     * - The device udid.
     */
    udid: string;
    /**
     * - Current device state, as it is visible in
     *   _adb devices -l_ output.
     */
    state: string;
};
/**
 * Additional properties returned when `verbose` is true.
 */
export type VerboseDevice = Device;
export type ExecResult = {
    /**
     * The stdout received from exec
     */
    stdout: string;
    /**
     * The stderr received from exec
     */
    stderr: string;
};
export type ShellExecOptions = {
    /**
     * - the name of the corresponding Appium's timeout capability
     * (used in the error messages).
     */
    timeoutCapName?: string | undefined;
    /**
     * - command execution timeout.
     */
    timeout?: number | undefined;
    /**
     * - Whether to run the given command as root.
     */
    privileged?: boolean | undefined;
    /**
     * - Whether response should include full exec output or just stdout.
     *   Potential values are full or stdout.
     *
     * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}module
     */
    outputFormat?: string | undefined;
};
export type AvdLaunchOptions = {
    /**
     * Additional emulator command line arguments
     */
    args: string | Array<string>;
    /**
     * Additional emulator environment variables
     */
    env: Object;
    /**
     * Emulator system language
     */
    language: string;
    /**
     * Emulator system country
     */
    country: string;
    /**
     * Emulator startup timeout in milliseconds
     */
    launchTimeout?: number | undefined;
    /**
     * The maximum period of time to wait until Emulator
     * is ready for usage in milliseconds
     */
    readyTimeout?: number | undefined;
    /**
     * The maximum number of startup retries
     */
    retryTimes?: number | undefined;
};
export type BinaryVersion = {
    /**
     * - The ADB binary version number
     */
    version: string;
    /**
     * - The ADB binary build number
     */
    build: number;
};
export type BridgeVersion = {
    /**
     * - The Android Debug Bridge version number
     */
    version: string;
};
export type Version = {
    /**
     * This version number might not be
     * be present for older ADB releases.
     */
    binary: BinaryVersion | null;
    bridge: BridgeVersion;
};
export type rootResult = {
    /**
     * True if the call to root/unroot was successful
     */
    isSuccessful: boolean;
    /**
     * True if the device was already rooted
     */
    wasAlreadyRooted: boolean;
};
export type SystemCalls = typeof systemCallMethods;
declare namespace systemCallMethods {
    /**
     * Retrieve full path to the given binary.
     *
     * @param {string} binaryName - The name of the binary.
     * @return {Promise<string>} Full path to the given binary including current SDK root.
     */
    function getSdkBinaryPath(binaryName: string): Promise<string>;
    const getBinaryNameForOS: ((binaryName: any) => string) & _.MemoizedFunction;
    /**
     * Retrieve full path to the given binary and caches it into `binaries`
     * property of the current ADB instance.
     *
     * @param {string} binaryName - Simple name of a binary file.
     * @return {Promise<string>} Full path to the given binary. The method tries
     *                  to enumerate all the known locations where the binary
     *                  might be located and stops the search as soon as the first
     *                  match is found on the local file system.
     * @throws {Error} If the binary with given name is not present at any
     *                 of known locations or Android SDK is not installed on the
     *                 local file system.
     */
    function getBinaryFromSdkRoot(binaryName: string): Promise<string>;
    /**
     * Retrieve full path to a binary file using the standard system lookup tool.
     *
     * @param {string} binaryName - The name of the binary.
     * @return {Promise<string>} Full path to the binary received from 'which'/'where'
     *                  output.
     * @throws {Error} If lookup tool returns non-zero return code.
     */
    function getBinaryFromPath(binaryName: string): Promise<string>;
    /**
     * @typedef {Object} ConnectedDevicesOptions
     * @property {?boolean} verbose - Whether to get long output, which includes extra properties in each device.
     * Akin to running `adb devices -l`.
     */
    /**
     * @typedef {Object} Device
     * @property {string} udid - The device udid.
     * @property {string} state - Current device state, as it is visible in
     *                            _adb devices -l_ output.
     */
    /**
     * @typedef {Device} VerboseDevice Additional properties returned when `verbose` is true.
     * @property {string} product - The product codename of the device, such as "razor".
     * @property {string} model - The model name of the device, such as "Nexus_7".
     * @property {string} device - The device codename, such as "flow".
     * @property {?string} usb - Represents the USB port the device is connected to, such as "1-1".
     * @property {?string} transport_id - The Transport ID for the device, such as "1".
     */
    /**
     * Retrieve the list of devices visible to adb.
     *
     * @param {?ConnectedDevicesOptions} [opts={}] - Additional options mapping.
     * @return {Promise<Device[]>} The list of devices or an empty list if
     *                          no devices are connected.
     * @throws {Error} If there was an error while listing devices.
     */
    function getConnectedDevices(opts?: ConnectedDevicesOptions | null | undefined): Promise<Device[]>;
    /**
     * Retrieve the list of devices visible to adb within the given timeout.
     *
     * @param {number} timeoutMs - The maximum number of milliseconds to get at least
     *                             one list item.
     * @return {Promise<Device[]>} The list of connected devices.
     * @throws {Error} If no connected devices can be detected within the given timeout.
     */
    function getDevicesWithRetry(timeoutMs?: number): Promise<Device[]>;
    /**
     * Kick current connection from host/device side and make it reconnect
     *
     * @param {?string} [target=offline] One of possible targets to reconnect:
     * offline, device or null
     * Providing `null` will cause reconnection to happen from the host side.
     *
     * @throws {Error} If either ADB version is too old and does not support this
     * command or there was a failure during reconnect.
     */
    function reconnect(target?: string | null | undefined): Promise<void>;
    /**
     * Restart adb server, unless _this.suppressKillServer_ property is true.
     */
    function restartAdb(): Promise<void>;
    /**
     * Kill adb server.
     */
    function killServer(): Promise<void>;
    const resetTelnetAuthToken: (() => Promise<boolean>) & _.MemoizedFunction;
    /**
     * Execute the given emulator command using _adb emu_ tool.
     *
     * @param {Array.<string>} cmd - The array of rest command line parameters.
     */
    function adbExecEmu(cmd: string[]): Promise<void>;
    const EXEC_OUTPUT_FORMAT: Readonly<{
        STDOUT: "stdout";
        FULL: "full";
    }>;
    /**
     * @typedef {Object} ExecResult
     * @property {string} stdout The stdout received from exec
     * @property {string} stderr The stderr received from exec
     */
    /**
     * Execute the given adb command.
     *
     * @param {Array.<string>} cmd - The array of rest command line parameters
     *                      or a single string parameter.
     * @param {Object} opts - Additional options mapping. See
     *                        {@link https://github.com/appium/node-teen_process}
     *                        for more details.
     *                        You can also set the additional `exclusive` param
     *                        to `true` that assures no other parallel adb commands
     *                        are going to be executed while the current one is running
     *                        You can set the `outputFormat` param to `stdout` to receive just the stdout
     *                        output (default) or `full` to receive the stdout and stderr response from a
     *                        command with a zero exit code
     * @return {Promise<string|ExecResult>} - Command's stdout or an object containing stdout and stderr.
     * @throws {Error} If the command returned non-zero exit code.
     */
    function adbExec(cmd: string[], opts?: Object): Promise<string | ExecResult>;
    /**
     * @typedef {Object} ShellExecOptions
     * @property {string} [timeoutCapName] - the name of the corresponding Appium's timeout capability
     * (used in the error messages).
     * @property {number} [timeout] - command execution timeout.
     * @property {boolean} [privileged=false] - Whether to run the given command as root.
     * @property {string} [outputFormat='stdout'] - Whether response should include full exec output or just stdout.
     *                                             Potential values are full or stdout.
     *
     * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}
     * module
     */
    /**
     * Execute the given command using _adb shell_ prefix.
     *
     * @param {string|string[]} cmd - The array of rest command line parameters or a single
     *                                      string parameter.
     * @param {ShellExecOptions} [opts={}] - Additional options mapping.
     * @return {Promise<string>} - Command's stdout.
     * @throws {Error} If the command returned non-zero exit code.
     */
    function shell(cmd: string | string[], opts?: ShellExecOptions | undefined): Promise<string>;
    function createSubProcess(args?: any[]): SubProcess;
    /**
     * Retrieve the current adb port.
     * @todo can probably deprecate this now that the logic is just to read this.adbPort
     * @return {number} The current adb port number.
     */
    function getAdbServerPort(): number;
    /**
     * Retrieve the current emulator port from _adb devives_ output.
     *
     * @return {Promsie<number>} The current emulator port.
     * @throws {Error} If there are no connected devices.
     */
    function getEmulatorPort(): Promsie<number>;
    /**
     * Retrieve the current emulator port by parsing emulator name string.
     *
     * @param {string} emStr - Emulator name string.
     * @return {number|false} Either the current emulator port or
     *                          _false_ if port number cannot be parsed.
     */
    function getPortFromEmulatorString(emStr: string): number | false;
    /**
     * Retrieve the list of currently connected emulators.
     *
     * @param {?ConnectedDevicesOptions} [opts={}] - Additional options mapping.
     * @return {Promise<Device[]>} The list of connected devices.
     */
    function getConnectedEmulators(opts?: ConnectedDevicesOptions | null | undefined): Promise<Device[]>;
    /**
     * Set _emulatorPort_ property of the current class.
     *
     * @param {number} emPort - The emulator port to be set.
     */
    function setEmulatorPort(emPort: number): void;
    /**
     * Set the identifier of the current device (_this.curDeviceId_).
     *
     * @param {string} - The device identifier.
     */
    function setDeviceId(deviceId: any): void;
    /**
     * Set the the current device object.
     *
     * @param {Device} deviceObj - The device object to be set.
     */
    function setDevice(deviceObj: Device): void;
    /**
     * Get the object for the currently running emulator.
     * !!! This method has a side effect - it implicitly changes the
     * `deviceId` (only if AVD with a matching name is found)
     * and `emulatorPort` instance properties.
     *
     * @param {string} avdName - Emulator name.
     * @return {Promise<Device|null>} Currently running emulator or _null_.
     */
    function getRunningAVD(avdName: string): Promise<Device | null>;
    /**
     * Get the object for the currently running emulator.
     *
     * @param {string} avdName - Emulator name.
     * @param {number} [timeoutMs=20000] - The maximum number of milliseconds
     *                                     to wait until at least one running AVD object
     *                                     is detected.
     * @return {Promise<Device|null>} Currently running emulator or _null_.
     * @throws {Error} If no device has been detected within the timeout.
     */
    function getRunningAVDWithRetry(avdName: string, timeoutMs?: number | undefined): Promise<Device | null>;
    /**
     * Shutdown all running emulators by killing their processes.
     *
     * @throws {Error} If killing tool returned non-zero return code.
     */
    function killAllEmulators(): Promise<void>;
    /**
     * Kill emulator with the given name. No error
     * is thrown is given avd does not exist/is not running.
     *
     * @param {?string} avdName - The name of the emulator to be killed. If empty,
     *                            the current emulator will be killed.
     * @param {?number} [timeout=60000] - The amount of time to wait before throwing
     *                                    an exception about unsuccessful killing
     * @return {Promise<boolean>} - True if the emulator was killed, false otherwise.
     * @throws {Error} if there was a failure by killing the emulator
     */
    function killEmulator(avdName?: string | null, timeout?: number | null | undefined): Promise<boolean>;
    /**
     * @typedef {Object} AvdLaunchOptions
     * @property {string|Array<string>} args Additional emulator command line arguments
     * @property {Object} env Additional emulator environment variables
     * @property {string} language Emulator system language
     * @property {string} country Emulator system country
     * @property {number} [launchTimeout=60000] Emulator startup timeout in milliseconds
     * @property {number} [readyTimeout=60000] The maximum period of time to wait until Emulator
     * is ready for usage in milliseconds
     * @property {number} [retryTimes=1] The maximum number of startup retries
     */
    /**
     * Start an emulator with given parameters and wait until it is fully started.
     *
     * @param {string} avdName - The name of an existing emulator.
     * @param {?AvdLaunchOptions} opts
     * @returns {Promise<SubProcess>} Emulator subprocess instance
     * @throws {Error} If the emulator fails to start within the given timeout.
     */
    function launchAVD(avdName: string, opts?: AvdLaunchOptions | null): Promise<SubProcess>;
    const getVersion: (() => Promise<{
        binary: {
            version: semver.SemVer | null;
            build: number;
        };
        bridge: {
            version: semver.SemVer | null;
        };
    }>) & _.MemoizedFunction;
    /**
     * Check if the current emulator is ready to accept further commands (booting completed).
     *
     * @param {number} [timeoutMs=20000] - The maximum number of milliseconds to wait.
     * @throws {Error} If the emulator is not ready within the given timeout.
     */
    function waitForEmulatorReady(timeoutMs?: number | undefined): Promise<void>;
    /**
     * Check if the current device is ready to accept further commands (booting completed).
     *
     * @param {number} [appDeviceReadyTimeout=30] - The maximum number of seconds to wait.
     * @throws {Error} If the device is not ready within the given timeout.
     */
    function waitForDevice(appDeviceReadyTimeout?: number | undefined): Promise<void>;
    /**
     * Reboot the current device and wait until it is completed.
     *
     * @param {number} [retries=DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.
     * @throws {Error} If the device failed to reboot and number of retries is exceeded.
     */
    function reboot(retries?: number | undefined): Promise<void>;
    /**
     * @typedef {Object} rootResult
     * @property {boolean} isSuccessful True if the call to root/unroot was successful
     * @property {boolean} wasAlreadyRooted True if the device was already rooted
     */
    /**
     * Switch adb server root privileges.
     * @param {boolean} isElevated - Should we elevate to to root or unroot? (default true)
     * @return {Promise<rootResult>}
     */
    function changeUserPrivileges(isElevated: boolean): Promise<rootResult>;
    /**
     * Switch adb server to root mode
     * @return {Promise<rootResult>}
     */
    function root(): Promise<rootResult>;
    /**
     * Switch adb server to non-root mode.
     *
     * @return {Promise<rootResult>}
     */
    function unroot(): Promise<rootResult>;
    /**
     * Checks whether the current user is root
     *
     * @return {Promise<boolean>} True if the user is root
     * @throws {Error} if there was an error while identifying
     * the user.
     */
    function isRoot(): Promise<boolean>;
    /**
     * Verify whether a remote path exists on the device under test.
     *
     * @param {string} remotePath - The remote path to verify.
     * @return {Promise<boolean>} True if the given path exists on the device.
     */
    function fileExists(remotePath: string): Promise<boolean>;
    /**
     * Get the output of _ls_ command on the device under test.
     *
     * @param {string} remotePath - The remote path (the first argument to the _ls_ command).
     * @param {string[]} [opts] - Additional _ls_ options.
     * @return {Promise<string[]>} The _ls_ output as an array of split lines.
     *                          An empty array is returned of the given _remotePath_
     *                          does not exist.
     */
    function ls(remotePath: string, opts?: string[] | undefined): Promise<string[]>;
    /**
     * Get the size of the particular file located on the device under test.
     *
     * @param {string} remotePath - The remote path to the file.
     * @return {Promise<number>} File size in bytes.
     * @throws {Error} If there was an error while getting the size of the given file.
     */
    function fileSize(remotePath: string): Promise<number>;
    /**
     * Installs the given certificate on a rooted real device or
     * an emulator. The emulator must be executed with `-writable-system`
     * command line option and adb daemon should be running in root
     * mode for this method to work properly. The method also requires
     * openssl tool to be available on the destination system.
     * Read https://github.com/appium/appium/issues/10964
     * for more details on this topic
     *
     * @param {Buffer|string} cert - base64-decoded content of the actual certificate
     * represented as a string or a buffer
     * @throws {Error} If openssl tool is not available on the destination system
     * or if there was an error while installing the certificate
     */
    function installMitmCertificate(cert: string | Buffer): Promise<void>;
    /**
     * Verifies if the given root certificate is already installed on the device.
     *
     * @param {Buffer|string} cert - base64-decoded content of the actual certificate
     * represented as a string or a buffer
     * @throws {Error} If openssl tool is not available on the destination system
     * or if there was an error while checking the certificate
     * @returns {Promise<boolean>} true if the given certificate is already installed
     */
    function isMitmCertificateInstalled(cert: string | Buffer): Promise<boolean>;
}
import { DEFAULT_ADB_EXEC_TIMEOUT } from '../helpers';
/**
 * Retrieve full path to the given binary.
 * This method does not have cache.
 *
 * @param {string} binaryName - Simple name of a binary file.
 *                              e.g. 'adb', 'android'
 * @return {Promise<string>} Full path to the given binary. The method tries
 *                  to enumerate all the known locations where the binary
 *                  might be located and stops the search as soon as the first
 *                  match is found on the local file system.
 *                  e.g. '/Path/To/Android/sdk/platform-tools/adb'
 * @throws {Error} If the binary with given name is not present at any
 *                 of known locations or Android SDK is not installed on the
 *                 local file system.
 */
export function getAndroidBinaryPath(binaryName: string): Promise<string>;
import _ from 'lodash';
import { SubProcess } from 'teen_process';
import semver from 'semver';
export { DEFAULT_ADB_EXEC_TIMEOUT };
//# sourceMappingURL=system-calls.d.ts.map