export default apkUtilsMethods;
export type StartUriOptions = {
    /**
     * - if `false` then adb won't wait
     * for the started activity to return the control
     */
    waitForLaunch?: boolean | undefined;
};
export type StartAppOptions = {
    /**
     * - The name of the application package
     */
    pkg: string;
    /**
     * - The name of the main application activity.
     * This or action is required in order to be able to launch an app.
     */
    activity?: string | undefined;
    /**
     * - The name of the intent action that will launch the required app.
     * This or activity is required in order to be able to launch an app.
     */
    action?: string | undefined;
    /**
     * - If this property is set to `true`
     * and the activity name does not start with '.' then the method
     * will try to add the missing dot and start the activity once more
     * if the first startup try fails.
     */
    retry?: boolean | undefined;
    /**
     * - Set it to `true` in order to forcefully
     * stop the activity if it is already running.
     */
    stopApp?: boolean | undefined;
    /**
     * - The name of the package to wait to on
     * startup (this only makes sense if this name is different from the one, which is set as `pkg`)
     */
    waitPkg?: string | undefined;
    /**
     * - The name of the activity to wait to on
     * startup (this only makes sense if this name is different from the one, which is set as `activity`)
     */
    waitActivity?: string | undefined;
    /**
     * - The number of milliseconds to wait until the
     * `waitActivity` is focused
     */
    waitDuration?: number | undefined;
    /**
     * - The number of the user profile to start
     * the given activity with. The default OS user profile (usually zero) is used
     * when this property is unset
     */
    user?: string | number | undefined;
    /**
     * - if `false` then adb won't wait
     * for the started activity to return the control
     */
    waitForLaunch?: boolean | undefined;
    category?: string | undefined;
    flags?: string | undefined;
    optionalIntentArguments?: string | undefined;
};
export type PackageActivityInfo = {
    /**
     * - The name of application package,
     *    for example 'com.acme.app'.
     */
    appPackage: string;
    /**
     * - The name of main application activity.
     */
    appActivity: string;
};
export type UninstallOptions = {
    /**
     * - The count of milliseconds to wait until the
     *          app is uninstalled.
     */
    timeout?: number | undefined;
    /**
     * - Set to true in order to keep the
     *          application data and cache folders after uninstall.
     */
    keepData?: boolean | undefined;
};
export type CachingOptions = {
    /**
     * - The count of milliseconds to wait until the
     *                     app is uploaded to the remote location.
     */
    timeout: number;
};
export type InstallOptions = {
    /**
     * - The count of milliseconds to wait until the
     *    app is installed.
     */
    timeout?: number | undefined;
    /**
     * - The timeout option name
     *    users can increase the timeout.
     */
    timeoutCapName?: string | undefined;
    /**
     * - Set to true in order to allow test
     *    packages installation.
     */
    allowTestPackages?: boolean | undefined;
    /**
     * - Set to true to install the app on sdcard
     *    instead of the device memory.
     */
    useSdcard?: boolean | undefined;
    /**
     * - Set to true in order to grant all the
     *    permissions requested in the application's manifest
     *    automatically after the installation is completed
     *    under Android 6+.
     */
    grantPermissions?: boolean | undefined;
    /**
     * - Set it to false if you don't want
     *    the application to be upgraded/reinstalled
     *    if it is already present on the device.
     */
    replace?: boolean | undefined;
    /**
     * - Forcefully disables incremental installs if set to `true`.
     *    Read https://developer.android.com/preview/features#incremental
     *    for more details.
     */
    noIncremental?: boolean | undefined;
};
export type InstallOrUpgradeOptions = {
    /**
     * - The count of milliseconds to wait until the
     *    app is installed.
     */
    timeout?: number | undefined;
    /**
     * - Set to true in order to allow test
     *    packages installation.
     */
    allowTestPackages?: boolean | undefined;
    /**
     * - Set to true to install the app on SDCard
     *    instead of the device memory.
     */
    useSdcard?: boolean | undefined;
    /**
     * - Set to true in order to grant all the
     *    permissions requested in the application's manifest
     *    automatically after the installation is completed
     *    under Android 6+.
     */
    grantPermissions?: boolean | undefined;
    /**
     * - Set to `true` in order to always prefer
     *    the current build over any installed packages having
     *    the same identifier
     */
    enforceCurrentBuild?: boolean | undefined;
};
export type InstallOrUpgradeResult = {
    /**
     * - Equals to `true` if the target app has been uninstalled
     *   before being installed
     */
    wasUninstalled: boolean;
    /**
     * - One of `adb.APP_INSTALL_STATE` states, which reflects
     *   the state of the application before being installed.
     */
    appState: APP_INSTALL_STATE;
};
export type AppInfo = {
    /**
     * - Package name, for example 'com.acme.app'.
     */
    name: string;
    /**
     * - Version code.
     */
    versionCode: number | null;
    /**
     * - Version name, for example '1.0'.
     */
    versionName: string | null;
    /**
     * - true if the app is installed on the device under test.
     */
    isInstalled: boolean | null;
};
export type ApkUtils = typeof apkUtilsMethods;
export const REMOTE_CACHE_ROOT: "/data/local/tmp/appium_cache";
declare namespace apkUtilsMethods {
    namespace APP_INSTALL_STATE {
        const UNKNOWN: string;
        const NOT_INSTALLED: string;
        const NEWER_VERSION_INSTALLED: string;
        const SAME_VERSION_INSTALLED: string;
        const OLDER_VERSION_INSTALLED: string;
    }
    /**
     * Check whether the particular package is present on the device under test.
     *
     * @param {string} pkg - The name of the package to check.
     * @return {Promise<boolean>} True if the package is installed.
     */
    function isAppInstalled(pkg: string): Promise<boolean>;
    /**
     * @typedef {Object} StartUriOptions
     * @property {boolean} [waitForLaunch=true] - if `false` then adb won't wait
     * for the started activity to return the control
     */
    /**
     * Start the particular URI on the device under test.
     *
     * @param {string} uri - The name of URI to start.
     * @param {string} pkg - The name of the package to start the URI with.
     * @param {StartUriOptions} opts
     */
    function startUri(uri: string, pkg: string, opts?: StartUriOptions): Promise<void>;
    /**
     * @typedef {Object} StartAppOptions
     * @property {string} pkg - The name of the application package
     * @property {string} [activity] - The name of the main application activity.
     * This or action is required in order to be able to launch an app.
     * @property {string} [action] - The name of the intent action that will launch the required app.
     * This or activity is required in order to be able to launch an app.
     * @property {boolean} [retry=true] - If this property is set to `true`
     * and the activity name does not start with '.' then the method
     * will try to add the missing dot and start the activity once more
     * if the first startup try fails.
     * @property {boolean} [stopApp=true] - Set it to `true` in order to forcefully
     * stop the activity if it is already running.
     * @property {string} [waitPkg] - The name of the package to wait to on
     * startup (this only makes sense if this name is different from the one, which is set as `pkg`)
     * @property {string} [waitActivity] - The name of the activity to wait to on
     * startup (this only makes sense if this name is different from the one, which is set as `activity`)
     * @property {number} [waitDuration] - The number of milliseconds to wait until the
     * `waitActivity` is focused
     * @property {string|number} [user] - The number of the user profile to start
     * the given activity with. The default OS user profile (usually zero) is used
     * when this property is unset
     * @property {boolean} [waitForLaunch=true] - if `false` then adb won't wait
     * for the started activity to return the control
     * @property {string} [category]
     * @property {string} [flags]
     * @property {string} [optionalIntentArguments]
     */
    /**
     * Start the particular package/activity on the device under test.
     *
     * @param {StartAppOptions} [startAppOptions={}] - Startup options mapping.
     * @return {Promise<string>} The output of the corresponding adb command.
     * @throws {Error} If there is an error while executing the activity
     */
    function startApp(startAppOptions?: StartAppOptions | undefined): Promise<string>;
    /**
     * Helper method to call `adb dumpsys window windows/displays`
     */
    function dumpWindows(): Promise<any>;
    /**
     * @typedef {Object} PackageActivityInfo
     * @property {string} appPackage - The name of application package,
     *                                  for example 'com.acme.app'.
     * @property {string} appActivity - The name of main application activity.
     */
    /**
     * Get the name of currently focused package and activity.
     *
     * @return {Promise<PackageActivityInfo>} The mapping, where property names are 'appPackage' and 'appActivity'.
     * @throws {Error} If there is an error while parsing the data.
     */
    function getFocusedPackageAndActivity(): Promise<PackageActivityInfo>;
    /**
     * Wait for the given activity to be focused/non-focused.
     *
     * @param {string} pkg - The name of the package to wait for.
     * @param {string} activity - The name of the activity, belonging to that package,
     *                            to wait for.
     * @param {boolean} waitForStop - Whether to wait until the activity is focused (true)
     *                                or is not focused (false).
     * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
     * @throws {error} If timeout happens.
     */
    function waitForActivityOrNot(pkg: string, activity: string, waitForStop: boolean, waitMs?: number | undefined): Promise<void>;
    /**
     * Wait for the given activity to be focused
     *
     * @param {string} pkg - The name of the package to wait for.
     * @param {string} activity - The name of the activity, belonging to that package,
     *                            to wait for.
     * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
     * @throws {error} If timeout happens.
     */
    function waitForActivity(pkg: string, act: any, waitMs?: number | undefined): Promise<void>;
    /**
     * Wait for the given activity to be non-focused.
     *
     * @param {string} pkg - The name of the package to wait for.
     * @param {string} activity - The name of the activity, belonging to that package,
     *                            to wait for.
     * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
     * @throws {error} If timeout happens.
     */
    function waitForNotActivity(pkg: string, act: any, waitMs?: number | undefined): Promise<void>;
    /**
     * @typedef {Object} UninstallOptions
     * @property {number} [timeout] - The count of milliseconds to wait until the
     *                                      app is uninstalled.
     * @property {boolean} [keepData] - Set to true in order to keep the
     *                                        application data and cache folders after uninstall.
     */
    /**
     * Uninstall the given package from the device under test.
     *
     * @param {string} pkg - The name of the package to be uninstalled.
     * @param {UninstallOptions} options - The set of uninstall options.
     * @return {Promise<boolean>} True if the package was found on the device and
     *                   successfully uninstalled.
     */
    function uninstallApk(pkg: string, options?: UninstallOptions): Promise<boolean>;
    /**
     * Install the package after it was pushed to the device under test.
     *
     * @param {string} apkPathOnDevice - The full path to the package on the device file system.
     * @param {object} [opts={}] - Additional exec options. See {@link https://github.com/appium/node-teen_process}
     *                             for more details on this parameter.
     * @throws {error} If there was a failure during application install.
     */
    function installFromDevicePath(apkPathOnDevice: string, opts?: object | undefined): Promise<void>;
    /**
     * @typedef {Object} CachingOptions
     * @property {number} timeout - The count of milliseconds to wait until the
     *                                                app is uploaded to the remote location.
     */
    /**
     * Caches the given APK at a remote location to speed up further APK deployments.
     *
     * @param {string} apkPath - Full path to the apk on the local FS
     * @param {CachingOptions} options - Caching options
     * @returns {Promise<string>} - Full path to the cached apk on the remote file system
     * @throws {Error} if there was a failure while caching the app
     */
    function cacheApk(apkPath: string, options?: CachingOptions): Promise<string>;
    /**
     * @typedef {Object} InstallOptions
     * @property {number} [timeout=60000] - The count of milliseconds to wait until the
     *                                      app is installed.
     * @property {string} [timeoutCapName=androidInstallTimeout] - The timeout option name
     *                                                             users can increase the timeout.
     * @property {boolean} [allowTestPackages=false] - Set to true in order to allow test
     *                                                 packages installation.
     * @property {boolean} [useSdcard=false] - Set to true to install the app on sdcard
     *                                         instead of the device memory.
     * @property {boolean} [grantPermissions=false] - Set to true in order to grant all the
     *                                                permissions requested in the application's manifest
     *                                                automatically after the installation is completed
     *                                                under Android 6+.
     * @property {boolean} [replace=true] - Set it to false if you don't want
     *                                      the application to be upgraded/reinstalled
     *                                      if it is already present on the device.
     * @property {boolean} [noIncremental=false] - Forcefully disables incremental installs if set to `true`.
     *                                             Read https://developer.android.com/preview/features#incremental
     *                                             for more details.
     */
    /**
     * Install the package from the local file system.
     *
     * @param {string} appPath - The full path to the local package.
     * @param {InstallOptions} [options] - The set of installation options.
     * @throws {Error} If an unexpected error happens during install.
     */
    function install(appPath: string, options?: InstallOptions | undefined): Promise<any>;
    /**
     * Retrieves the current installation state of the particular application
     *
     * @param {string} appPath - Full path to the application
     * @param {string} pkg - Package identifier. If omitted then the script will
     *                        try to extract it on its own
     * @returns {Promise<string>} One of `APP_INSTALL_STATE` constants
     */
    function getApplicationInstallState(appPath: string, pkg?: string): Promise<string>;
    /**
     * @typedef {Object} InstallOrUpgradeOptions
     * @property {number} [timeout=60000] - The count of milliseconds to wait until the
     *                                      app is installed.
     * @property {boolean} [allowTestPackages=false] - Set to true in order to allow test
     *                                                 packages installation.
     * @property {boolean} [useSdcard=false] - Set to true to install the app on SDCard
     *                                         instead of the device memory.
     * @property {boolean} [grantPermissions=false] - Set to true in order to grant all the
     *                                                permissions requested in the application's manifest
     *                                                automatically after the installation is completed
     *                                                under Android 6+.
     * @property {boolean} [enforceCurrentBuild=false] - Set to `true` in order to always prefer
     *                                                   the current build over any installed packages having
     *                                                   the same identifier
     */
    /**
     * @typedef {Object} InstallOrUpgradeResult
     * @property {boolean} wasUninstalled - Equals to `true` if the target app has been uninstalled
     *                                      before being installed
     * @property {APP_INSTALL_STATE} appState - One of `adb.APP_INSTALL_STATE` states, which reflects
     *                                          the state of the application before being installed.
     */
    /**
     * Install the package from the local file system or upgrade it if an older
     * version of the same package is already installed.
     *
     * @param {string} appPath - The full path to the local package.
     * @param {string} [pkg] - The name of the installed package. The method will
     *                        perform faster if it is set.
     * @param {InstallOrUpgradeOptions} [options] - Set of install options.
     * @throws {Error} If an unexpected error happens during install.
     * @returns {Promise<InstallOrUpgradeResult>}
     */
    function installOrUpgrade(appPath: string, pkg?: string | undefined, options?: InstallOrUpgradeOptions | undefined): Promise<InstallOrUpgradeResult>;
    /**
     * Extract string resources from the given package on local file system.
     *
     * @param {string} appPath - The full path to the .apk(s) package.
     * @param {string|null} [language] - The name of the language to extract the resources for.
     *                             The default language is used if this equals to `null`/`undefined`
     * @param {string} out - The name of the destination folder on the local file system to
     *                       store the extracted file to.
     * @return {Promise<import('@appium/types').StringRecord>} A mapping object, where properties are: 'apkStrings', containing
     *                  parsed resource file represented as JSON object, and 'localPath',
     *                  containing the path to the extracted file on the local file system.
     */
    function extractStringsFromApk(appPath: string, language?: string | null | undefined, out: string): Promise<import("@appium/types").StringRecord<any>>;
    /**
     * Get the language name of the device under test.
     *
     * @return {Promise<string>} The name of device language.
     */
    function getDeviceLanguage(): Promise<string>;
    /**
     * Get the country name of the device under test.
     *
     * @return {Promise<string>} The name of device country.
     */
    function getDeviceCountry(): Promise<string>;
    /**
     * Get the locale name of the device under test.
     *
     * @return {Promise<string>} The name of device locale.
     */
    function getDeviceLocale(): Promise<string>;
    /**
     * Set the locale name of the device under test and the format of the locale is en-US, for example.
     * This method call setDeviceLanguageCountry, so, please use setDeviceLanguageCountry as possible.
     *
     * @param {string} locale - Names of the device language and the country connected with `-`. e.g. en-US.
     */
    function setDeviceLocale(locale: string): Promise<void>;
    /**
     * Make sure current device locale is expected or not.
     *
     * @privateRemarks FIXME: language or country is required
     * @param {string} [language] - Language. The language field is case insensitive, but Locale always canonicalizes to lower case.
     * @param {string} [country] - Country. The language field is case insensitive, but Locale always canonicalizes to lower case.
     * @param {string} [script] - Script. The script field is case insensitive but Locale always canonicalizes to title case.
     *
     * @return {Promise<boolean>} If current locale is language and country as arguments, return true.
     */
    function ensureCurrentLocale(language?: string | undefined, country?: string | undefined, script?: string | undefined): Promise<boolean>;
    /**
     * Set the locale name of the device under test.
     *
     * @privateRemarks FIXME: language or country is required
     * @param {string} [language] - Language. The language field is case insensitive, but Locale always canonicalizes to lower case.
     *                            format: [a-zA-Z]{2,8}. e.g. en, ja : https://developer.android.com/reference/java/util/Locale.html
     * @param {string} [country] - Country. The country (region) field is case insensitive, but Locale always canonicalizes to upper case.
     *                            format: [a-zA-Z]{2} | [0-9]{3}. e.g. US, JP : https://developer.android.com/reference/java/util/Locale.html
     * @param {string} [script] - Script. The script field is case insensitive but Locale always canonicalizes to title case.
     *                            format: [a-zA-Z]{4}. e.g. Hans in zh-Hans-CN : https://developer.android.com/reference/java/util/Locale.html
     */
    function setDeviceLanguageCountry(language?: string | undefined, country?: string | undefined, script?: string | undefined): Promise<void>;
    /**
     * @typedef {Object} AppInfo
     * @property {string} name - Package name, for example 'com.acme.app'.
     * @property {number?} versionCode - Version code.
     * @property {string?} versionName - Version name, for example '1.0'.
     * @property {boolean?} isInstalled - true if the app is installed on the device under test.
     */
    /**
     * Get the package info from local apk file.
     *
     * @param {string} appPath - The full path to existing .apk(s) package on the local
     *                           file system.
     * @return {Promise<AppInfo|{}>} The parsed application information.
     */
    function getApkInfo(appPath: string): Promise<{} | AppInfo>;
    /**
     * Get the package info from the installed application.
     *
     * @param {string} pkg - The name of the installed package.
     * @return {Promise<AppInfo>} The parsed application information.
     */
    function getPackageInfo(pkg: string): Promise<AppInfo>;
    /**
     * Fetches base.apk of the given package to the local file system
     *
     * @param {string} pkg The package identifier (must be already installed on the device)
     * @param {string} tmpDir The destination folder path
     * @returns {Promise<string>} Full path to the downloaded file
     * @throws {Error} If there was an error while fetching the .apk
     */
    function pullApk(pkg: string, tmpDir: string): Promise<string>;
    /**
     * Activates the given application or launches it if necessary.
     * The action literally simulates
     * clicking the corresponding application icon on the dashboard.
     *
     * @param {string} appId - Application package identifier
     * @throws {Error} If the app cannot be activated
     */
    function activateApp(appId: string): Promise<void>;
}
//# sourceMappingURL=apk-utils.d.ts.map