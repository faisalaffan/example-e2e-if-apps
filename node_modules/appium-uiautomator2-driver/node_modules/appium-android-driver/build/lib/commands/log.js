"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.helpers = exports.commands = void 0;
const logger_1 = __importDefault(require("../logger"));
const os_1 = __importDefault(require("os"));
const lodash_1 = __importDefault(require("lodash"));
const ws_1 = __importDefault(require("ws"));
const driver_1 = require("appium/driver");
const GET_SERVER_LOGS_FEATURE = 'get_server_logs';
let commands = {}, helpers = {}, extensions = {};
exports.commands = commands;
exports.helpers = helpers;
const WEBSOCKET_ENDPOINT = (sessionId) => `${driver_1.DEFAULT_WS_PATHNAME_PREFIX}/session/${sessionId}/appium/device/logcat`;
// https://github.com/SeleniumHQ/selenium/blob/0d425676b3c9df261dd641917f867d4d5ce7774d/java/client/src/org/openqa/selenium/logging/LogEntry.java
function toLogRecord(timestamp, level, message) {
    return {
        timestamp,
        level,
        message,
    };
}
extensions.supportedLogTypes = {
    logcat: {
        description: 'Logs for Android applications on real device and emulators via ADB',
        getter: async (self) => await self.adb.getLogcatLogs(),
    },
    bugreport: {
        description: `'adb bugreport' output for advanced issues diagnostic`,
        getter: async (self) => {
            const output = await self.adb.bugreport();
            const timestamp = Date.now();
            return output.split(os_1.default.EOL)
                .map((x) => toLogRecord(timestamp, 'ALL', x));
        },
    },
    server: {
        description: 'Appium server logs',
        getter: (self) => {
            self.ensureFeatureEnabled(GET_SERVER_LOGS_FEATURE);
            const timestamp = Date.now();
            return logger_1.default.unwrap().record
                .map((x) => toLogRecord(timestamp, 'ALL', lodash_1.default.isEmpty(x.prefix) ? x.message : `[${x.prefix}] ${x.message}`));
        },
    },
};
/**
 * Starts Android logcat broadcast websocket on the same host and port
 * where Appium server is running at `/ws/session/:sessionId:/appium/logcat` endpoint. The method
 * will return immediately if the web socket is already listening.
 *
 * Each connected websocket listener will receive logcat log lines
 * as soon as they are visible to Appium.
 */
commands.mobileStartLogsBroadcast = async function mobileStartLogsBroadcast() {
    const pathname = WEBSOCKET_ENDPOINT(this.sessionId);
    if (!lodash_1.default.isEmpty(await this.server.getWebSocketHandlers(pathname))) {
        logger_1.default.debug(`The logcat broadcasting web socket server is already listening at ${pathname}`);
        return;
    }
    logger_1.default.info(`Starting logcat broadcasting on web socket server ` +
        `${JSON.stringify(this.server.address())} to ${pathname}`);
    // https://github.com/websockets/ws/blob/master/doc/ws.md
    const wss = new ws_1.default.Server({
        noServer: true,
    });
    wss.on('connection', (ws, req) => {
        if (req) {
            const remoteIp = lodash_1.default.isEmpty(req.headers['x-forwarded-for'])
                ? req.connection?.remoteAddress
                : req.headers['x-forwarded-for'];
            logger_1.default.debug(`Established a new logcat listener web socket connection from ${remoteIp}`);
        }
        else {
            logger_1.default.debug('Established a new logcat listener web socket connection');
        }
        if (lodash_1.default.isEmpty(this._logcatWebsocketListener)) {
            this._logcatWebsocketListener = (logRecord) => {
                if (ws?.readyState === ws_1.default.OPEN) {
                    ws.send(logRecord.message);
                }
            };
        }
        this.adb.setLogcatListener(this._logcatWebsocketListener);
        ws.on('close', (code, reason) => {
            if (!lodash_1.default.isEmpty(this._logcatWebsocketListener)) {
                try {
                    this.adb.removeLogcatListener(this._logcatWebsocketListener);
                }
                catch (ign) { }
                this._logcatWebsocketListener = null;
            }
            let closeMsg = 'Logcat listener web socket is closed.';
            if (!lodash_1.default.isEmpty(code)) {
                closeMsg += ` Code: ${code}.`;
            }
            if (!lodash_1.default.isEmpty(reason)) {
                closeMsg += ` Reason: ${reason.toString()}.`;
            }
            logger_1.default.debug(closeMsg);
        });
    });
    await this.server.addWebSocketHandler(pathname, wss);
};
/**
 * Stops the previously started logcat broadcasting wesocket server.
 * This method will return immediately if no server is running.
 */
commands.mobileStopLogsBroadcast = async function mobileStopLogsBroadcast() {
    const pathname = WEBSOCKET_ENDPOINT(this.sessionId);
    if (lodash_1.default.isEmpty(await this.server.getWebSocketHandlers(pathname))) {
        return;
    }
    logger_1.default.debug(`Stopping logcat broadcasting on web socket server ` +
        `${JSON.stringify(this.server.address())} to ${pathname}`);
    await this.server.removeWebSocketHandler(pathname);
};
commands.getLogTypes = async function getLogTypes() {
    const nativeLogTypes = await driver_1.BaseDriver.prototype.getLogTypes.call(this);
    if (this.isWebContext()) {
        const webLogTypes = await this.chromedriver.jwproxy.command('/log/types', 'GET');
        return [...nativeLogTypes, ...webLogTypes];
    }
    return nativeLogTypes;
};
commands.getLog = async function getLog(logType) {
    if (this.isWebContext() && !lodash_1.default.keys(this.supportedLogTypes).includes(logType)) {
        return await this.chromedriver.jwproxy.command('/log', 'POST', { type: logType });
    }
    return await driver_1.BaseDriver.prototype.getLog.call(this, logType);
};
Object.assign(extensions, commands, helpers);
exports.default = extensions;
//# sourceMappingURL=log.js.map