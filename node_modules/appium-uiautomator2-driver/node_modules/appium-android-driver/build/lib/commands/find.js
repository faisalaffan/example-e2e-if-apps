"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.helpers = void 0;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
let helpers = {}, extensions = {};
exports.helpers = helpers;
/**
 * Reason for isolating doFindElementOrEls from findElOrEls is for reusing findElOrEls
 * across android-drivers (like appium-uiautomator2-driver) to avoid code duplication.
 * Other android-drivers (like appium-uiautomator2-driver) need to override doFindElementOrEls
 * to facilitate findElOrEls.
 */
helpers.doFindElementOrEls = async function doFindElementOrEls(params) {
    return await this.bootstrap.sendAction('find', params);
};
// stategy: locator strategy
// selector: the actual selector for finding an element
// mult: multiple elements or just one?
// context: finding an element from the root context? or starting from another element
helpers.findElOrEls = async function findElOrEls(strategy, selector, mult, context = '') {
    if (!selector) {
        throw new Error('Must provide a selector when finding elements');
    }
    let params = {
        strategy,
        selector,
        context,
        multiple: mult
    };
    let element;
    let doFind = async () => {
        try {
            element = await this.doFindElementOrEls(params);
        }
        catch (err) {
            // if the error that comes back is from a proxied request, we need to
            // unwrap it to its actual protocol error first
            if ((0, driver_1.isErrorType)(err, driver_1.errors.ProxyRequestError)) {
                err = err.getActualError(); // eslint-disable-line no-ex-assign
            }
            // now we have to inspect the error to determine if it is a no such
            // element error, based on the shape of the error object from
            // appium/driver
            if ((0, driver_1.isErrorType)(err, driver_1.errors.NoSuchElementError)) {
                // we are fine with this, just indicate a retry
                return false;
            }
            throw err;
        }
        // we want to return false if we want to potentially try again
        return !lodash_1.default.isEmpty(element);
    };
    try {
        await this.implicitWaitForCondition(doFind);
    }
    catch (err) {
        if (err.message && err.message.match(/Condition unmet/)) {
            // only get here if we are looking for multiple elements
            // condition was not met setting res to empty array
            element = [];
        }
        else {
            throw err;
        }
    }
    if (mult) {
        return element;
    }
    if (lodash_1.default.isEmpty(element)) {
        throw new driver_1.errors.NoSuchElementError();
    }
    return element;
};
Object.assign(extensions, helpers);
exports.default = extensions;
//# sourceMappingURL=find.js.map