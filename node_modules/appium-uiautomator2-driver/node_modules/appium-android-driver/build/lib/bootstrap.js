"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMMAND_TYPES = exports.AndroidBootstrap = void 0;
const uiautomator_1 = __importDefault(require("./uiautomator"));
const net_1 = __importDefault(require("net"));
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const bluebird_1 = __importDefault(require("bluebird"));
const support_1 = require("@appium/support");
const log = support_1.logger.getLogger('AndroidBootstrap');
const COMMAND_TYPES = {
    ACTION: 'action',
    SHUTDOWN: 'shutdown'
};
exports.COMMAND_TYPES = COMMAND_TYPES;
const SEND_COMMAND_TIMEOUT = 1 * 60 * 1000;
/**
 * Calculates the path to the current module's root folder
 *
 * @returns {string} The full path to module root
 * @throws {Error} If the current module root folder cannot be determined
 */
const getModuleRoot = lodash_1.default.memoize(async function getModuleRoot() {
    let currentDir = path_1.default.dirname(path_1.default.resolve(__filename));
    let isAtFsRoot = false;
    while (!isAtFsRoot) {
        const manifestPath = path_1.default.join(currentDir, 'package.json');
        try {
            if (await support_1.fs.exists(manifestPath) &&
                JSON.parse(await support_1.fs.readFile(manifestPath, 'utf8')).name === 'appium-android-driver') {
                return currentDir;
            }
        }
        catch (ign) { }
        currentDir = path_1.default.dirname(currentDir);
        isAtFsRoot = currentDir.length <= path_1.default.dirname(currentDir).length;
    }
    throw new Error('Cannot find the root folder of the appium-android-driver Node.js module');
});
class AndroidBootstrap {
    constructor(adb, systemPort = 4724, webSocket = undefined) {
        this.adb = adb;
        this.systemPort = systemPort;
        this.webSocket = webSocket;
        this.ignoreUnexpectedShutdown = false;
    }
    get onUnexpectedShutdown() {
        if (!this._onUnexpectedShutdownPromise) {
            let reject;
            this._onUnexpectedShutdownPromise = new bluebird_1.default(function _onUnexpectedShutdownPromise(_resolve, _reject) {
                reject = _reject;
            });
            this._onUnexpectedShutdownPromise.cancel = reject;
        }
        return this._onUnexpectedShutdownPromise;
    }
    async start(appPackage, disableAndroidWatchers = false, acceptSslCerts = false) {
        try {
            const startDetector = (s) => /Appium Socket Server Ready/.test(s);
            const bootstrapJar = path_1.default.resolve(await getModuleRoot(), 'bootstrap', 'bin', 'AppiumBootstrap.jar');
            await this.init();
            await this.adb.forwardPort(this.systemPort, 4724);
            this.process = await this.uiAutomator.start(bootstrapJar, 'io.appium.android.bootstrap.Bootstrap', startDetector, '-e', 'pkg', appPackage, '-e', 'disableAndroidWatchers', disableAndroidWatchers, '-e', 'acceptSslCerts', acceptSslCerts);
            // process the output
            this.process.on('output', (stdout, stderr) => {
                const alertRe = /Emitting system alert message/;
                if (alertRe.test(stdout)) {
                    log.debug('Emitting alert message...');
                    if (this.webSocket) {
                        this.webSocket.sockets.emit('alert', { message: stdout });
                    }
                }
                // the bootstrap logger wraps its own log lines with
                // [APPIUM-UIAUTO] ... [APPIUM-UIAUTO]
                // and leaves actual UiAutomator logs as they are
                let stdoutLines = (stdout || '').split('\n');
                const uiautoLog = /\[APPIUM-UIAUTO\](.+)\[\/APPIUM-UIAUTO\]/;
                for (let line of stdoutLines) {
                    if (line.trim()) {
                        if (uiautoLog.test(line)) {
                            let innerLine = uiautoLog.exec(line)[1].trim();
                            let logMethod = log.info.bind(log);
                            // if the bootstrap log considers something debug, log that as
                            // debug and not info
                            if (/\[debug\]/.test(innerLine)) {
                                logMethod = log.debug.bind(log);
                            }
                            logMethod(`[BOOTSTRAP LOG] ${innerLine}`);
                        }
                        else {
                            log.debug(`[UIAUTO STDOUT] ${line}`);
                        }
                    }
                }
                let stderrLines = (stderr || '').split('\n');
                for (let line of stderrLines) {
                    if (line.trim()) {
                        log.debug(`[UIAUTO STDERR] ${line}`);
                    }
                }
            });
            // only return when the socket client has connected
            return await new bluebird_1.default((resolve, reject) => {
                try {
                    this.socketClient = net_1.default.connect(this.systemPort, '127.0.0.1');
                    // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
                    this.socketClient.on('error', (err) => {
                        if (!this.ignoreUnexpectedShutdown) {
                            throw new Error(`Android bootstrap socket crashed: ${err}`);
                        }
                    });
                    this.socketClient.once('connect', () => {
                        log.info('Android bootstrap socket is now connected');
                        resolve();
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
        }
        catch (err) {
            log.errorAndThrow(`Error occured while starting AndroidBootstrap. Original error: ${err}`);
        }
    }
    async sendCommand(type, extra = {}) {
        if (!this.socketClient) {
            throw new Error('Socket connection closed unexpectedly');
        }
        return await new bluebird_1.default((resolve, reject) => {
            let cmd = Object.assign({ cmd: type }, extra);
            let cmdJson = `${JSON.stringify(cmd)} \n`;
            log.debug(`Sending command to android: ${lodash_1.default.truncate(cmdJson, { length: 1000 }).trim()}`);
            this.socketClient.write(cmdJson);
            this.socketClient.setEncoding('utf8');
            let streamData = '';
            let sendCommandTimeoutHandler = null;
            this.socketClient.on('data', (data) => {
                if (sendCommandTimeoutHandler) {
                    clearTimeout(sendCommandTimeoutHandler);
                }
                log.debug('Received command result from bootstrap');
                try {
                    streamData = JSON.parse(streamData + data);
                    // we successfully parsed JSON so we've got all the data,
                    // remove the socket listener and evaluate
                    this.socketClient.removeAllListeners('data');
                    if (streamData.status === 0) {
                        return resolve(streamData.value);
                    }
                    reject((0, driver_1.errorFromCode)(streamData.status, streamData.value));
                }
                catch (err) {
                    if (!lodash_1.default.isString(streamData)) {
                        log.error('Got an unexpected error inside socket listener');
                        log.error(err.stack);
                        return reject((0, driver_1.errorFromCode)(13, err.message));
                    }
                    log.debug(`Stream still not complete, waiting up to ${SEND_COMMAND_TIMEOUT}ms for the data to arrive`);
                    streamData += data;
                    sendCommandTimeoutHandler = setTimeout(() => {
                        const errMsg = `Server socket stopped responding. The recent response was '${streamData}'`;
                        log.error(errMsg);
                        this.socketClient.removeAllListeners('data');
                        reject((0, driver_1.errorFromCode)(13, errMsg));
                    }, SEND_COMMAND_TIMEOUT);
                }
            });
        });
    }
    async sendAction(action, params = {}) {
        let extra = { action, params };
        return await this.sendCommand(COMMAND_TYPES.ACTION, extra);
    }
    async shutdown() {
        if (!this.uiAutomator) {
            log.warn('Cannot shut down Android bootstrap; it has already shut down');
            return;
        }
        // remove listners so we don't trigger unexpected shutdown
        this.uiAutomator.removeAllListeners(uiautomator_1.default.EVENT_CHANGED);
        if (this.socketClient) {
            await this.sendCommand(COMMAND_TYPES.SHUTDOWN);
        }
        await this.uiAutomator.shutdown();
        this.uiAutomator = null;
    }
    // this helper function makes unit testing easier.
    async init() {
        this.uiAutomator = new uiautomator_1.default(this.adb);
        // Handle unexpected UiAutomator shutdown
        this.uiAutomator.on(uiautomator_1.default.EVENT_CHANGED, (msg) => {
            if (msg.state === uiautomator_1.default.STATE_STOPPED) {
                this.uiAutomator = null;
                this.onUnexpectedShutdown.cancel(new Error('UiAUtomator shut down unexpectedly'));
            }
        });
    }
    set ignoreUnexpectedShutdown(ignore) {
        log.debug(`${ignore ? 'Ignoring' : 'Watching for'} bootstrap disconnect`);
        this._ignoreUnexpectedShutdown = ignore;
    }
    get ignoreUnexpectedShutdown() {
        return this._ignoreUnexpectedShutdown;
    }
}
exports.AndroidBootstrap = AndroidBootstrap;
exports.default = AndroidBootstrap;
//# sourceMappingURL=bootstrap.js.map