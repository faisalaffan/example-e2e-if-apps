export default helpers;
export type WebviewProc = {
    /**
     * - The webview process name (as returned by
     * getPotentialWebviewProcs
     */
    proc: string;
    /**
     * - The actual webview context name
     */
    webview: string;
};
export type WebviewProps = {
    /**
     * The name of the Devtools Unix socket
     */
    proc: string;
    /**
     * The web view alias. Looks like `WEBVIEW_`
     * prefix plus PID or package name
     */
    webview: string;
    /**
     * Webview information as it is retrieved by
     * /json/version CDP endpoint
     */
    info: any | null;
    /**
     * Webview pages list as it is retrieved by
     * /json/list CDP endpoint
     */
    pages: Array<any> | null;
};
export type DetailCollectionOptions = {
    /**
     * The starting port to use for webview page
     * presence check (if not the default of 9222).
     */
    webviewDevtoolsPort: (string | number) | null;
    /**
     * Whether to check for webview
     * pages presence
     */
    ensureWebviewsHavePages: boolean | null;
    /**
     * Whether to collect
     * web view details and send them to Chromedriver constructor, so it could
     * select a binary more precisely based on this info.
     */
    enableWebviewDetailsCollection: boolean;
};
export type GetWebviewsOpts = {
    /**
     * [null] - device socket name
     */
    androidDeviceSocket: string;
    /**
     * [true] - whether to check for webview
     * page presence
     */
    ensureWebviewsHavePages: boolean;
    /**
     * [9222] - port to use for webview page
     * presence check.
     */
    webviewDevtoolsPort: number;
    /**
     * [true] - whether to collect
     * web view details and send them to Chromedriver constructor, so it could
     * select a binary more precisely based on this info.
     */
    enableWebviewDetailsCollection: boolean;
};
export type WebviewsMapping = {
    /**
     * See note on WebviewProps
     */
    proc: string;
    /**
     * See note on WebviewProps
     */
    webview: string;
    /**
     * See note on WebviewProps
     */
    info: any | null;
    /**
     * See note on WebviewProps
     */
    pages: Array<any> | null;
};
export type ProcessInfo = {
    /**
     * The process name
     */
    name: string;
    /**
     * The process id (if could be retrieved)
     */
    id: string | null;
};
export type WebViewDetails = {
    /**
     * - Web view process details
     */
    process: ProcessInfo | null;
    /**
     * - Web view details as returned by /json/version CDP endpoint, for example:
     * {
     * "Browser": "Chrome/72.0.3601.0",
     * "Protocol-Version": "1.3",
     * "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3601.0 Safari/537.36",
     * "V8-Version": "7.2.233",
     * "WebKit-Version": "537.36 (@cfede9db1d154de0468cb0538479f34c0755a0f4)",
     * "webSocketDebuggerUrl": "ws://localhost:9222/devtools/browser/b0b8a4fb-bb17-4359-9533-a8d9f3908bd8"
     * }
     */
    info: any;
};
export namespace helpers {
    /**
     * Take a webview name like WEBVIEW_4296 and use 'adb shell ps' to figure out
     * which app package is associated with that webview. One of the reasons we
     * want to do this is to make sure we're listing webviews for the actual AUT,
     * not some other running app
     *
     * @param {object} adb - an ADB instance
     * @param {string} webview - a webview process name
     *
     * @returns {string} - the package name of the app running the webview
     * @throws {Error} If there was a failure while retrieving the process name
     */
    function procFromWebview(adb: any, webview: string): string;
    /**
     * Parse webview names for getContexts
     *
     * @param {Array<WebviewsMapping>} webviewsMapping See note on getWebViewsMapping
     * @param {GetWebviewsOpts} opts See note on getWebViewsMapping
     * @return {Array.<string>} - a list of webview names
     */
    function parseWebviewNames(webviewsMapping: WebviewsMapping[], { ensureWebviewsHavePages, isChromeSession }?: GetWebviewsOpts): string[];
    /**
     * @typedef {Object} GetWebviewsOpts
     * @property {string} androidDeviceSocket [null] - device socket name
     * @property {boolean} ensureWebviewsHavePages [true] - whether to check for webview
     * page presence
     * @property {number} webviewDevtoolsPort [9222] - port to use for webview page
     * presence check.
     * @property {boolean} enableWebviewDetailsCollection [true] - whether to collect
     * web view details and send them to Chromedriver constructor, so it could
     * select a binary more precisely based on this info.
     */
    /**
     * @typedef {Object} WebviewsMapping
     * @property {string} proc See note on WebviewProps
     * @property {string} webview See note on WebviewProps
     * @property {?Object} info See note on WebviewProps
     * @property {?Array<Object>} pages See note on WebviewProps
     * @propery {?string} webviewName An actual webview name for switching context
     */
    /**
     * Get a list of available webviews mapping by introspecting processes with adb,
     * where webviews are listed. It's possible to pass in a 'deviceSocket' arg, which
     * limits the webview possibilities to the one running on the Chromium devtools
     * socket we're interested in (see note on webviewsFromProcs). We can also
     * direct this method to verify whether a particular webview process actually
     * has any pages (if a process exists but no pages are found, Chromedriver will
     * not actually be able to connect to it, so this serves as a guard for that
     * strange failure mode). The strategy for checking whether any pages are
     * active involves sending a request to the remote debug server on the device,
     * hence it is also possible to specify the port on the host machine which
     * should be used for this communication.
     *
     * @param {object} adb - an ADB instance
     * @param {GetWebviewsOpts} opts
     *
     * @return {Array<WebviewsMapping>} webviewsMapping
     */
    function getWebViewsMapping(adb: any, { androidDeviceSocket, ensureWebviewsHavePages, webviewDevtoolsPort, enableWebviewDetailsCollection }?: GetWebviewsOpts): WebviewsMapping[];
    /**
     * @typedef {Object} ProcessInfo
     * @property {string} name The process name
     * @property {?string} id The process id (if could be retrieved)
     */
    /**
     * @typedef {Object} WebViewDetails
     * @property {?ProcessInfo} process - Web view process details
     * @property {Object} info - Web view details as returned by /json/version CDP endpoint, for example:
     * {
     *  "Browser": "Chrome/72.0.3601.0",
     *  "Protocol-Version": "1.3",
     *  "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3601.0 Safari/537.36",
     *  "V8-Version": "7.2.233",
     *  "WebKit-Version": "537.36 (@cfede9db1d154de0468cb0538479f34c0755a0f4)",
     *  "webSocketDebuggerUrl": "ws://localhost:9222/devtools/browser/b0b8a4fb-bb17-4359-9533-a8d9f3908bd8"
     * }
     */
    /**
     * Retrieves web view details previously cached by `getWebviews` call
     *
     * @param {ADB} adb ADB instance
     * @param {string} webview The name of the web view
     * @returns {?WebViewDetails} Either `undefined` or the recent web view details
     */
    function getWebviewDetails(adb: ADB, webview: string): WebViewDetails | null;
    /**
     * Create Chrome driver capabilities based on the provided
     * Appium capabilities
     *
     * @param {Object} opts User-provided capabilities object
     * @param {string} deviceId The identifier of the Android device under test
     * @param {?WebViewDetails} webViewDetails
     * @returns {Object} The capabilities object.
     * See https://chromedriver.chromium.org/capabilities for more details.
     */
    function createChromedriverCaps(opts: any, deviceId: string, webViewDetails: WebViewDetails | null): any;
}
export const NATIVE_WIN: "NATIVE_APP";
export const WEBVIEW_WIN: "WEBVIEW";
export const WEBVIEW_BASE: string;
export const CHROMIUM_WIN: "CHROMIUM";
export const KNOWN_CHROME_PACKAGE_NAMES: string[];
//# sourceMappingURL=webview-helpers.d.ts.map