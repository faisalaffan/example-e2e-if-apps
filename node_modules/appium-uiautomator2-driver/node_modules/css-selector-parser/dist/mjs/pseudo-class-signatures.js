export const emptyPseudoClassSignatures = {};
export const defaultPseudoClassSignature = {
    type: 'String',
    optional: true
};
function calculatePseudoClassSignature(types) {
    const result = {
        optional: false
    };
    function setResultType(type) {
        if (result.type && result.type !== type) {
            throw new Error(`Conflicting pseudo-class argument type: "${result.type}" vs "${type}".`);
        }
        result.type = type;
    }
    for (const type of types) {
        if (type === 'NoArgument') {
            result.optional = true;
        }
        if (type === 'Formula') {
            setResultType('Formula');
        }
        if (type === 'FormulaOfSelector') {
            setResultType('Formula');
            result.ofSelector = true;
        }
        if (type === 'String') {
            setResultType('String');
        }
        if (type === 'Selector') {
            setResultType('Selector');
        }
    }
    return result;
}
export function inverseCategories(obj) {
    const result = {};
    for (const category of Object.keys(obj)) {
        const items = obj[category];
        if (items) {
            for (const item of items) {
                (result[item] || (result[item] = [])).push(category);
            }
        }
    }
    return result;
}
export function calculatePseudoClassSignatures(definitions) {
    const pseudoClassesToArgumentTypes = inverseCategories(definitions);
    const result = {};
    for (const pseudoClass of Object.keys(pseudoClassesToArgumentTypes)) {
        const argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
        if (argumentTypes) {
            result[pseudoClass] = calculatePseudoClassSignature(argumentTypes);
        }
    }
    return result;
}
